<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>扭蛋持有榜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC:400,700&display=swap" rel="stylesheet">
  <style>
    body{
      font-family:'Noto Sans TC',sans-serif;
      background:url(https://shierusha.github.io/create-student/imgs/citybg.png) center/cover fixed no-repeat;
      margin:0; padding:2rem;
    }
    .container{
      max-width:1100px; margin:auto; background:#fff; border-radius:16px;
      box-shadow:0 2px 16px #0001; padding:1.6rem 1.4rem 2rem;
      backdrop-filter:saturate(140%) blur(2px);
    }
    h1{margin:.2rem 0 0; color:#143158; text-align:center; letter-spacing:.04em}
    .hr{height:4px; width:78%; background:#1767a0; margin:.6rem auto 1.6rem; border-radius:2px; opacity:.9}
    .section-title{
      margin:1.0rem 0 .6rem; font-size:1.2rem; color:#143158; font-weight:700;
      display:flex; align-items:center; gap:.6rem;
    }
    .section-title .tag{background:#1767a0; color:#fff; padding:.2rem .55rem; border-radius:.5rem; font-size:.85rem;}
    .section-title .right{color:#0f2d52}
    .grid{ display:grid; grid-template-columns: repeat(2, 1fr); gap: 1.2rem 1rem; }
    @media (max-width:860px){ .grid{grid-template-columns:1fr;} }
    .card{
      background:#eef4f5; border-radius:14px;
      box-shadow:0 2px 10px #0002, 0 0 0 2.5px rgba(33,41,55,.5);
      padding:1rem .9rem;
    }
    .player-row{display:flex;align-items:baseline;justify-content:space-between;gap:.6rem}
    .player{font-weight:700; color:#0f2d52; word-break:break-all;}
    .remain{color:#1767a0;font-weight:900;white-space:nowrap}
    .list{ color:#303a4d; line-height:1.55; white-space:pre-line; margin-top:.35rem; }
    .muted{color:#667; font-size:.95rem}
    .event-title{
      margin:1em 0 0.5em; color:#0f2d52; font-weight:800; display:flex; align-items:center; gap:.5rem;
    }
    .ev-badge{
      background:#1767a0; color:#fff; font-weight:800; font-size:.78rem;
      padding:.12rem .5rem; border-radius:.4rem;
    }
    .loading{ text-align:center; color:#143158; padding:1rem 0 .4rem; }
    .err{ color:#9b0b18; text-align:center; }

    .rightbox{ display:flex; flex-direction:column; align-items:flex-end; gap:.15rem; }
    .progress{ color:#1767a0; font-weight:700; font-size:.95rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1 id="pageTitle">全服隱藏／限定持有榜</h1>
    <div class="hr"></div>

    <div id="msg" class="loading">載入中…</div>

    <!-- 限定款（依活動分段；或 lim= 活動時只顯示該活動） -->
    <div class="section-title" id="limitedSectionTitle" style="display:none;">
      <span class="tag">LIMITED</span>
      <span class="right" id="limitedRight">期間限定</span>
    </div>
    <div id="limitedWrap"></div>

    <!-- 隱藏款（若帶 lim=，就不顯示這段） -->
    <div class="section-title" id="hiddenSectionTitle" style="display:none;">
      <span class="tag">HIDDEN</span>
      <span class="right">隱藏款</span>
    </div>
    <div id="hiddenGrid" class="grid"></div>
  </div>

<script>
/* ====== Supabase 連線 ====== */
/* B：圖書館（讀池與 owned_characters, counters） */
const B = window.supabase.createClient(
  'https://ogzpfrkwnqqaitytncla.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9nenBmcmt3bnFxYWl0eXRuY2xhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxODQzNzEsImV4cCI6MjA3MDc2MDM3MX0.Ls83xOXcKIW7FUcavr8_sOs37I18VGFWYNW3sNFRS24'
);
/* A：玩家名稱（RPC：get_player_username） */
const A = window.supabase.createClient(
  'https://wfhwhvodgikpducrhgda.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmaHdodm9kZ2lrcGR1Y3JoZ2RhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgwMTAwNjEsImV4cCI6MjA2MzU4NjA2MX0.P6P-x4SxjiR4VdWH6VFgY_ktgMac_OzuI4Bl7HWskz8'
);

const G = t => B.schema('gacha').from(t);
const $  = (s, r=document)=>r.querySelector(s);

/* ====== URL 參數（活動過濾） ====== */
const params = new URLSearchParams(location.search);
const eventFilter = params.get('lim')?.trim() || '';

/* ====== 動態標題 ====== */
const pageTitleEl = $('#pageTitle');
const limitedRightEl = $('#limitedRight');
const limitedSectionTitle = $('#limitedSectionTitle');
const hiddenSectionTitle = $('#hiddenSectionTitle');
if (eventFilter) {
  pageTitleEl.textContent = '限定活動持有榜';
  limitedRightEl.textContent = '期間限定';
} else {
  pageTitleEl.textContent = '全服隱藏／限定持有榜';
  limitedRightEl.textContent = '期間限定';
}

/* ====== 讀角色池（名稱表、白名單、總數） ====== */
async function loadPools(){
  const [{data:h=[]},{data:l=[]}] = await Promise.all([
    G('hidden_characters').select('id,name').order('id',{ascending:true}),
    G('limited_characters').select('id,event_name,name').order('event_name',{ascending:true}).order('id',{ascending:true}),
  ]);

  // 隱藏：id -> name
  const hiddenNameById = new Map(h.map(x=>[x.id, x.name]));

  // 限定：複合鍵 "event#id" -> name（避免不同活動 id 撞名）
  const limitedNameByKey = new Map(l.map(x=>[`${x.event_name}#${x.id}`, x.name]));

  // 限定合法白名單 + id -> event_name（用來矯正 owned 內寫錯活動的資料）
  const limitedPairs = new Set(l.map(x=>`${x.event_name}#${x.id}`));
  const limitedEventById = new Map(l.map(x=>[x.id, x.event_name]));

  // 統計
  const hiddenTotal = h.length;
  const limitedCountsByEvent = new Map();
  l.forEach(row=>{
    const ev = row.event_name || '';
    limitedCountsByEvent.set(ev, (limitedCountsByEvent.get(ev) || 0) + 1);
  });

  return { hiddenNameById, limitedNameByKey, limitedPairs, limitedEventById, hiddenTotal, limitedCountsByEvent };
}

/* 活動排序（用 starts_at） */
async function loadEventOrder(){
  const { data=[] } = await G('events').select('event_name,starts_at').order('starts_at',{ascending:true});
  const order = new Map(); data.forEach((ev, idx)=> order.set(ev.event_name, idx));
  return order;
}

/* ====== 撈全服 owned（只抓 hidden/limited；lim= 僅該活動的 limited） ====== */
async function loadOwned(){
  const { data: rows=[] } = await G('owned_characters')
    .select('player_id,rarity,event_name,character_id,count');

  let filtered = rows.filter(r => r.rarity === 'hidden' || r.rarity === 'limited');

  if (eventFilter) {
    filtered = filtered.filter(r => r.rarity === 'limited' && (r.event_name || '') === eventFilter);
  }
  return filtered;
}

/* ====== 讀 counters：拿剩餘抽數（max_draws - total_draws，最低 0） ====== */
async function loadCountersRemaining(){
  const { data = [] } = await G('counters').select('player_id,total_draws,max_draws');
  const map = new Map();
  data.forEach(r => {
    const td = r.total_draws ?? 0;
    const md = r.max_draws ?? 1000;
    const remain = Math.max(0, md - td);
    map.set(r.player_id, remain);
  });
  return map;
}

/* ====== 玩家名稱查詢（A 專案 RPC；避免 RLS） ====== */
async function fetchNames(playerIds){
  const uniq = [...new Set(playerIds)];
  const map = new Map();
  await Promise.all(uniq.map(async id=>{
    try{
      const { data } = await A.rpc('get_player_username', { p_id: id });
      map.set(id, (data && String(data).trim()) || '玩家');
    }catch{
      map.set(id, '玩家');
    }
  }));
  return map;
}

/* ====== 渲染：隱藏款 ====== */
function renderHidden({ hiddenByPlayer, nameById, playerNameMap, countersRemainMap, hiddenTotal }){
  const grid = $('#hiddenGrid');
  grid.innerHTML = '';

  const players = [...hiddenByPlayer.keys()].sort((a,b)=>{
    return (playerNameMap.get(a)||'').localeCompare(playerNameMap.get(b)||'', 'zh-Hant');
  });

  players.forEach(pid=>{
    const items = hiddenByPlayer.get(pid) || [];
    if (!items.length) return;

    items.sort((a,b)=>a.character_id - b.character_id);

    const card = document.createElement('div');
    card.className = 'card';

    const header = document.createElement('div');
    header.className = 'player-row';

    const title = document.createElement('div');
    title.className = 'player';
    title.textContent = playerNameMap.get(pid) || '玩家';

    // 右側：剩餘抽數 + 蒐集進度（隱藏）
    const right = document.createElement('div');
    right.className = 'rightbox';

    const remain = document.createElement('div');
    remain.className = 'remain';
    remain.textContent = `剩餘抽數：${countersRemainMap.get(pid) ?? 0}`;

    const progress = document.createElement('div');
    progress.className = 'progress';
    const ownedKinds = items.length; // 隱藏款持有種類數
    progress.textContent = `蒐集：(${ownedKinds}/${hiddenTotal})`;

    right.appendChild(remain);
    right.appendChild(progress);

    header.appendChild(title);
    header.appendChild(right);
    card.appendChild(header);

    const list = document.createElement('div');
    list.className = 'list';
    list.innerHTML = items.map(it=>{
      const nm = nameById.get(it.character_id) || `#${it.character_id}`;
      return `${escapeHtml(nm)} × ${it.count}`;
    }).join('\n');
    card.appendChild(list);

    grid.appendChild(card);
  });

  hiddenSectionTitle.style.display = players.length ? 'flex' : 'none';
  if (!players.length) {
    grid.innerHTML = `<div class="muted">無隱藏款持有資料</div>`;
  }
}

/* ====== 渲染：限定款（依活動分段；若 lim 僅顯示單一活動） ====== */
function renderLimited({ limitedByEventThenPlayer, nameByKey, playerNameMap, countersRemainMap, limitedCountsByEvent, eventOrder }){
  const wrap = $('#limitedWrap');
  wrap.innerHTML = '';

  // 依 starts_at 排序；沒有排序資訊的用字母序墊底
  const events = [...limitedByEventThenPlayer.keys()].sort((a,b)=>{
    const ai = eventOrder.has(a) ? eventOrder.get(a) : 1e9;
    const bi = eventOrder.has(b) ? eventOrder.get(b) : 1e9;
    if (ai !== bi) return ai - bi;
    return a.localeCompare(b,'zh-Hant');
  });

  limitedSectionTitle.style.display = events.length ? 'flex' : 'none';

  if (!events.length){
    wrap.innerHTML = `<div class="muted">無限定款持有資料</div>`;
    return;
  }

  for (const ev of events){
    // 活動小標題（含藍色「限定」徽章）
    const evTitle = document.createElement('div');
    evTitle.className = 'event-title';
    evTitle.innerHTML = `<span class="ev-badge">限定</span> ${escapeHtml(ev)}`;
    wrap.appendChild(evTitle);

    const grid = document.createElement('div');
    grid.className = 'grid';

    const perPlayer = limitedByEventThenPlayer.get(ev) || new Map();
    const players = [...perPlayer.keys()].sort((a,b)=>{
      return (playerNameMap.get(a)||'').localeCompare(playerNameMap.get(b)||'', 'zh-Hant');
    });

    const denom = limitedCountsByEvent.get(ev) ?? 0; // 此活動總種類數

    players.forEach(pid=>{
      const items = perPlayer.get(pid) || [];
      if (!items.length) return;

      items.sort((a,b)=>a.character_id - b.character_id);

      const card = document.createElement('div');
      card.className = 'card';

      const header = document.createElement('div');
      header.className = 'player-row';

      const title = document.createElement('div');
      title.className = 'player';
      title.textContent = playerNameMap.get(pid) || '玩家';

      // 右側：剩餘抽數 + 蒐集進度（此活動）
      const right = document.createElement('div');
      right.className = 'rightbox';

      const remain = document.createElement('div');
      remain.className = 'remain';
      remain.textContent = `剩餘抽數：${countersRemainMap.get(pid) ?? 0}`;

      const progress = document.createElement('div');
      progress.className = 'progress';
      const ownedKinds = items.length; // 這位玩家在「此活動」擁有幾種
      progress.textContent = `蒐集：(${ownedKinds}/${denom})`;

      right.appendChild(remain);
      right.appendChild(progress);

      header.appendChild(title);
      header.appendChild(right);
      card.appendChild(header);

      const list = document.createElement('div');
      list.className = 'list';
      list.innerHTML = items.map(it=>{
        const nm = nameByKey.get(`${ev}#${it.character_id}`) || `#${it.character_id}`;
        return `${escapeHtml(nm)} × ${it.count}`;
      }).join('\n');
      card.appendChild(list);

      grid.appendChild(card);
    });

    wrap.appendChild(grid);
  }
}

/* ====== 主流程 ====== */
(async function main(){
  try{
    $('#msg').textContent = '載入角色池…';
    const pools = await loadPools();
    const eventOrder = await loadEventOrder();

    $('#msg').textContent = '彙整持有資料…';
    const owned = await loadOwned();

    // 分組
    const hiddenByPlayer = new Map();           // pid -> [{character_id,count}]
    const limitedByEventThenPlayer = new Map(); // event -> (pid -> [{character_id,count}])
    const allPids = new Set();

    for (const r of owned){
      allPids.add(r.player_id);

      if (r.rarity === 'hidden'){
        const arr = hiddenByPlayer.get(r.player_id) || [];
        arr.push({ character_id: r.character_id, count: r.count });
        hiddenByPlayer.set(r.player_id, arr);
        continue;
      }

      if (r.rarity === 'limited'){
        // 以 owned 內 event_name 為基準；若 (event,id) 不合法，依池表矯正活動
        let ev = r.event_name || '';
        const key = `${ev}#${r.character_id}`;
        if (!pools.limitedPairs.has(key)) {
          const fixEv = pools.limitedEventById.get(r.character_id);
          if (fixEv) ev = fixEv;
        }

        if (!limitedByEventThenPlayer.has(ev)) limitedByEventThenPlayer.set(ev, new Map());
        const mp = limitedByEventThenPlayer.get(ev);
        const arr = mp.get(r.player_id) || [];
        arr.push({ character_id: r.character_id, count: r.count });
        mp.set(r.player_id, arr);
      }
    }

    $('#msg').textContent = '取得玩家名稱與剩餘抽數…';
    const [playerNameMap, countersRemainMap] = await Promise.all([
      fetchNames([...allPids]),      // pid -> username（專案A RPC）
      loadCountersRemaining()        // pid -> remain（專案B）
    ]);

    // 渲染
    $('#msg').textContent = '';
    renderLimited({
      limitedByEventThenPlayer,
      nameByKey: pools.limitedNameByKey,
      playerNameMap,
      countersRemainMap,
      limitedCountsByEvent: pools.limitedCountsByEvent,
      eventOrder
    });

    // 帶 lim= 時，不顯示隱藏區塊
    if (!eventFilter) {
      renderHidden({
        hiddenByPlayer,
        nameById: pools.hiddenNameById,
        playerNameMap,
        countersRemainMap,
        hiddenTotal: pools.hiddenTotal
      });
    } else {
      hiddenSectionTitle.style.display = 'none';
      $('#hiddenGrid').innerHTML = '';
    }

  }catch(e){
    console.error(e);
    const m = $('#msg');
    m.className = 'err';
    m.textContent = '讀取失敗：' + (e?.message || e);
  }
})();

/* ====== Utils ====== */
function escapeHtml(s){
  return (s||'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
}
</script>
</body>
</html>
