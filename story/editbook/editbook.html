<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>謝爾夏｜電子書編輯器</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- 字體 -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&family=Noto+Sans+TC:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
/* ========== Reset / Base ========== */
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:#e6ebff;
  font-family:'Noto Sans TC',system-ui,-apple-system,Segoe UI,sans-serif;
  background:#000 url('https://shierusha.github.io/school-battle/teachers/img/8.webp') center top / cover no-repeat fixed;
}
/* 隱藏滾動條但保留滾動 */
html, body { overflow-y: auto; }
body { -ms-overflow-style: none; scrollbar-width: none; }
body::-webkit-scrollbar { width:0; height:0; }

/* ========== App Bar ========== */
.appbar {
    position: fixed;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    background: rgba(15, 27, 51, .85);
    border-bottom: 1px solid #223057;
    height: 30px; 
    width: 100vw;
}
.brand{display:flex;gap:.6rem;align-items:center;font-weight:700}
#bookTitle{outline:none}
#bookTitle[contenteditable="true"]{border-bottom:1px dashed #8aa1ff}
.tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

/* ========== 舞台區 ========== */
.stage{
  position: absolute;
  left: 50%;
  top: 60px;
  transform: translateX(-50%);
  width: 90%;
  height: 100vh;
}
.scaler{ position:relative; width:100%; }

/* ========== 按鈕（保留你的） ========== */
.btn{ background:#16244a; border:1px solid #3a4a78; color:#fff; padding:2px 10px; border-radius:10px; cursor:pointer }
.btn.primary{ background:#6f82ff; border-color:#6f82ff }
.btn.danger{ background:#2a0f18; border-color:#6b1b2e; color:#ffb3c2 }
.btn.ghost{border-color:#ffffff33 }
.side{ position:fixed;  display:flex; gap:8px; z-index:90 }
.side.left{     left: 10px;   top: 33px; }
.side.right{ right:10px; top: 33px; }
.dock{ position:fixed; left:0; right:0; bottom:1%; display:flex; gap:10px; justify-content:center; z-index:90 }

/* ========== 文字方向（外觀） ========== */
.mode-ltr .page{ writing-mode: horizontal-tb; }
.mode-rtl .page{ writing-mode: vertical-rl;  letter-spacing: 0.1em; }
.mode-ltr .single-page{ writing-mode: horizontal-tb; }
.mode-rtl .single-page{ writing-mode: vertical-rl; letter-spacing: 0.1em; }

/* ===== BookFlip 必要 CSS（請勿移除） ===== */
.book, .book * { user-select:none; -webkit-user-select:none; }
.book { position:absolute; top:0; color:black; }
.paper {
  width:100%; height:100%;
  position:absolute; top:0; left:0;
  transform-style:preserve-3d;
  background:#FFF;
  border: 1px solid #555;
}
.page {
  width:100%; height:100%;
  position:absolute; top:0; left:0;
  display:flex;
  backface-visibility:hidden; -webkit-backface-visibility:hidden;
  padding: calc(20px * var(--scale, 1));
}
.back { transform: rotateY(180deg); }
.paper.dir-ltr { transform-origin: left center; }
.paper.dir-rtl { transform-origin: right center; }

.single-stage { width:100%; height:100%; position:relative; overflow:hidden; }
.single-page  { width:100%; height:100%; position:absolute; top:0; left:0; display:flex; will-change:transform; background:#FFF; padding: calc(20px * var(--scale, 1)); }

/* 字級比例（方案2） */
.book-scope { font-size: calc(16px * var(--scale, 1)); }

/* ========== 章節角標＋頁碼 ========== */
.page-meta { position: absolute; pointer-events: none;     font-size: .7em;    opacity: .7;}
.meta-chapter { max-width: 45%; }

.meta-tl { top: 5px;  left: 6px; }
.meta-tr { top: 5px;  right: 3px; }
.meta-bl { bottom: 5px; left: 6px; }
.meta-br { bottom: 5px; right: 6px; }

/* ========== 四種頁型（底線版） ========== */
.page.page--divider_light,
.single-page.page--divider_light,
.page.page--divider_dark,
.single-page.page--divider_dark {
  display:flex; align-items:center; justify-content:center; text-align:center;
}
/* 不顯示角標 */
.page--divider_light .page-meta,
.page--divider_dark  .page-meta,
.page--illustration  .page-meta { display:none !important; }
/* 配色 */
.page.page--divider_light, .single-page.page--divider_light { background:#fff; color:#000; }
.page.page--divider_dark,  .single-page.page--divider_dark  { background:#555; color:#fff; }
/* 圖片滿版 */
.page.page--illustration, .single-page.page--illustration {
  background-size: cover; background-position: center; background-repeat: no-repeat; padding:0 !important;
}

/* ========== TOC Modal（自適應高度） ========== */
.modal-overlay { position: fixed; inset: 0; z-index: 2000; display: none; align-items: center; justify-content: center; animation: modal-fadein-bg 0.25s; background: rgba(0,0,0,0.45); }
.modal-overlay.show { display: flex; }
@keyframes modal-fadein-bg { from { background: rgba(0,0,0,0);} to { background: rgba(0,0,0,0.45);} }
.modal-content { background: rgb(13 27 77 / 82%); border-radius: 18px; border: 2px solid #1eb5e5; box-shadow: 0 0 16px 2px #62f1fe88, 0 8px 32px #1eb5e5aa; width: 500px; max-width: 93vw; height: auto; max-height: 80vh; display: flex; flex-direction: column; overflow: hidden; animation: modal-pop 0.32s cubic-bezier(.42,1.4,.51,1.01); }
@keyframes modal-pop { from { opacity: 0; transform: scale(0.92);} to { opacity: 1; transform: scale(1);} }
.modal-header { background: none; padding: 15px 20px 0px 24px; color: #fff; font-size: 1.5em; font-weight: bold; letter-spacing: 1px; text-shadow: 0 1px 4px #000a; }
.modal-header::after { content: ""; display: block; height: 5px; width: 70%; margin: 0.5rem 0 0 0; border-radius: 2px; background: linear-gradient(to right, #53e2ff99 65%, #53e2ff00 100%); pointer-events: none; }
.modal-body { color: #fff; padding: 12px 24px 16px 24px; font-size: 1.05em; line-height: 1.55; text-shadow: 0 1px 4px #0008; overflow-y: auto; word-break: break-word; white-space: normal; max-height: 64vh; scrollbar-width: none; -ms-overflow-style: none; }
.modal-body::-webkit-scrollbar { display: none; }
.toc-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 6px 0; border-bottom: 1px dashed #53e2ff33; cursor: pointer; }
.toc-row:hover { background: #0d1b4d66; }
.toc-row .toc-title { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.toc-row .toc-page  { opacity: .9; }

/* 讓頁碼永遠水平書寫（單頁/雙頁都適用） */
.page .meta-page,
.single-page .meta-page {
  writing-mode: horizontal-tb !important;
  text-orientation: mixed !important; /* 確保數字不是直立顯示 */
  letter-spacing: 0 !important;       /* 避免繼承垂直模式的字距 */
  text-combine-upright: none !important;
}

/* 650px 以下換版型 */
@media (max-width: 650px) {
.stage{height: 85vh;}
#bookTitle {    width: 10em;}
.appbar {    height: 65px;}
.tools {    gap: 1px;    flex-direction: column-reverse;}
.stage {  top: 85px;  width: 80%;}
.side.right {bottom: 65px;        left: 50%;        transform: translateX(-50%);        right: 0px;        top: auto;        justify-content: center;        width: 100%;}
.side.left {    top: 65px;}}


    /* 編輯時不要出現巨大黑框/外框 */
.story { outline: none !important; }
.story:focus { outline: none !important; box-shadow: none !important; border: none !important; }
/* 也一併避免點擊高亮 */
.story { -webkit-tap-highlight-color: transparent; }
/* 你本來就有 overflow:hidden；再保險一下不顯示滾動條 */
.story::-webkit-scrollbar { width: 0; height: 0; }


  </style>
</head>

<body class="mode-ltr">
  <!-- 上方導覽 -->
  <div class="appbar">
    <div class="brand">書名:<span id="bookTitle" contenteditable="true">未命名書籍</span></div>
    <div class="tools">
      <div>
        <span>頁面數：</span><b id="lblCount">0</b>
        <span style="width:5px"></span>
      </div>
      <div>
        <button class="btn primary" id="btnSave">儲存</button>
        <button class="btn" id="btnBack">回書單</button>
      </div>
    </div>
  </div>

  <!-- 左側工具列（TOC 不再隱藏） -->
  <div class="side left">
    <button class="btn ghost" id="btnTOC">目錄</button>
    <button class="btn ghost" id="btnFontUp">A+</button>
    <button class="btn ghost" id="btnFontDown">A-</button>
    <button class="btn ghost" id="btnBold"><b>B</b></button>
    <button class="btn ghost" id="btnItalic"><i>I</i></button>
    <button class="btn ghost" id="btnUnderline"><u>U</u></button>
  </div>

  <!-- 右側工具列 -->
  <div class="side right">
   <button class="btn ghost" id="btnToggleDir" style="display: none;">文字方向</button>
    <button class="btn ghost" id="btnToggleBind" style="display: none;">長/短邊</button>
    <button class="btn ghost" id="btnToggleView">單/雙頁</button>
  </div>

  <!-- 中央舞台 -->
  <div class="stage">
    <div class="scaler" id="scaler">
      <div class="book" id="bookCanvas">
        <!-- ✅ 封面保留（插件不覆蓋） -->
        <div class="paper">
          <div class="page front">首頁</div>
          <div class="page back"></div>
        </div>
        <!-- 正文由 JS 追加 -->
      </div>
    </div>
  </div>

  <!-- 下方 Dock（不隱藏） -->
<div class="dock" style="bottom:34px;">


    <button class="btn ghost" id="btnleft">&lt;</button>
    <button class="btn" id="btnInsertChapter">插入/修改章節</button>
    <button class="btn" id="btnInsertPage" >新增紙</button>
    <button class="btn danger" id="btnDeleteBlank">刪除白紙</button>
    <button class="btn ghost" id="btnright">&gt;</button>

  </div>
  <div class="dock">
        <button class="btn ghost" id="btnStageMinus"> - </button>
    <button class="btn" data-style="novel">一般文本</button>
    <button class="btn" data-style="divider-light">白置中</button>
    <button class="btn" data-style="divider-dark">黑置中</button>
    <button class="btn" data-style="illustration">圖片頁</button>
        <button class="btn ghost" id="btnStagePlus"> + </button>
  </div>

  <!-- TOC Modal -->
  <div id="tocModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="tocTitle">
      <div class="modal-header" id="tocTitle">目錄</div>
      <div class="modal-body" id="tocBody"></div>
    </div>
  </div>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- Supabase：用書櫃換來的長簽建立 Client，並把 SB/BOOK_ID 暴露成全域 -->
<script>
(function () {
  const SUPABASE_URL = "https://ogzpfrkwnqqaitytncla.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9nenBmcmt3bnFxYWl0eXRuY2xhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxODQzNzEsImV4cCI6MjA3MDc2MDM3MX0.Ls83xOXcKIW7FUcavr8_sOs37I18VGFWYNW3sNFRS24";

  const url = new URL(location.href);
  const bookId = url.searchParams.get('bookid') || '';
  if (!bookId) { alert('缺少 ?bookid= 參數'); }
  window.BOOK_ID = bookId;
  // 也建立同名全域變數給外部檔案（如果它們用的是 SB/BOOK_ID）
  // 注意：這裡用 var，確保是 global binding
  // （很多外掛/舊檔會直接用 SB 而不是 window.SB）
  var BOOK_ID = bookId;

  const token = localStorage.getItem('xer_b_jwt') || '';
  if (!token) {
    alert('尚未登入或登入逾期，將返回玩家中心。');
    location.replace('https://shierusha.github.io/create-student/player');
    return;
  }

  const SBClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
    global: { headers: { Authorization: `Bearer ${token}` } }
  });
  window.SB = SBClient;
  // 同上，暴露成全域變數
  var SB = SBClient;
})();
</script>



  <!-- 外掛-->
  <script src="book-flip.js"></script>
  <!-- 應用層-->
<script src="app.js"></script>
<script src="editor-core.js"></script>
<script src="sheet-ops.js"></script>
<script src="paste-flow.js"></script>
<script src="text-controls.js"></script>
<!-- 放在你的 <script src="text-controls.js"></script> 後面即可 -->
<script>
/* chapters.js — 插入/編輯章節（LOCAL）
 * - 依目前頁（EditorCore.getFocusedDbIndex）新增/編輯/移除章節
 * - 寫回 CHAPTERS_DB + persistDraft() + 角標重繪
 */
(function () {
  if (!window.EditorCore) return;

  const btn = document.getElementById('btnInsertChapter');
  if (!btn) return;

  function upsertChapterAt(dbIndex, title) {
    if (!Array.isArray(window.CHAPTERS_DB)) window.CHAPTERS_DB = [];

    const t = (title || '').trim();
    const i = CHAPTERS_DB.findIndex(ch => (ch.page_index|0) === (dbIndex|0));

    if (t === '') {
      // 空值 → 移除該頁章節
      if (i >= 0) CHAPTERS_DB.splice(i, 1);
    } else {
      if (i >= 0) {
        CHAPTERS_DB[i].title = t;
      } else {
        CHAPTERS_DB.push({ title: t, page_index: dbIndex|0 });
      }
    }

    CHAPTERS_DB.sort((a, b) => (a.page_index|0) - (b.page_index|0));

    try { window.persistDraft && window.persistDraft(); } catch(_) {}

    // 角標/頁碼立即更新（章節角標靠它）
    try { window.renderMetaForAllPages && renderMetaForAllPages(); } catch(_) {}
  }

  function onClickInsertChapter() {
    // 取得目前頁；封面（dbIndex=0）就視為第 1 頁
    let dbIndex = window.EditorCore.getFocusedDbIndex() || 1;
    if (dbIndex <= 0) dbIndex = 1;

    // 帶入原標題（若該頁已是章節）
    const existing = (window.CHAPTERS_DB || []).find(ch => (ch.page_index|0) === (dbIndex|0));
    const defaultTitle = existing ? existing.title : '';

    const title = prompt('請輸入章節名稱（留空=不設定/刪除）：', defaultTitle);
    if (title === null) return; // 取消不動作

    upsertChapterAt(dbIndex, title);
  }

  btn.addEventListener('click', onClickInsertChapter);

  // 導出（給其他模組需要時呼叫）
  window.Chapters = { upsertChapterAt };
})();
</script>

<script src="page-style.js"></script>
<script>
/* －／＋ 調整 .stage 寬度，每次 5%，不做任何持久化 */
(function () {
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
  }

  onReady(function () {
    const stageEl = document.querySelector('.stage');
    const minus   = document.getElementById('btnStageMinus');
    const plus    = document.getElementById('btnStagePlus');
    if (!stageEl || !minus || !plus) return;

    const STEP = 5, MIN = 20, MAX = 140;
    const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));

    // 初始：若沒設定 inline，預設 90%
    let pct = (function () {
      const m = /(\d+(?:\.\d+)?)%/.exec(stageEl.style.width || '');
      return m ? +m[1] : 90;
    })();

    function reflow(){
      if (typeof window.applyLayout === 'function') window.applyLayout();
      if (typeof window.afterLayoutRedraw === 'function') window.afterLayoutRedraw();
      if (typeof window.applyLayout !== 'function' && typeof window.afterLayoutRedraw !== 'function') {
        window.dispatchEvent(new Event('resize'));
      }
    }
    function apply(){
      pct = clamp(Math.round(pct), MIN, MAX);
      stageEl.style.width = pct + '%';
      reflow();
    }
    function dec(){ pct -= STEP; apply(); }
    function inc(){ pct += STEP; apply(); }

    minus.addEventListener('click', dec);
    plus .addEventListener('click', inc);

    // 依目前值先套一次（不影響原本 90% 外觀）
    apply();
  });
})();
</script>
<script>
/* ===== 安全順序儲存：處理換位/插入/刪除 + 章節外鍵，成功後回抓覆寫 LOCAL ===== */
(function(){
  const BACK_URL = 'https://shierusha.github.io/library/story/book-chest';

  /* === 新增：Discord 通知設定（有開 SHARED_TOKEN 驗證才填） === */
  const NOTIFY_ENDPOINT = 'https://ogzpfrkwnqqaitytncla.supabase.co/functions/v1/notify-discord';
  const SHARED_TOKEN = ''; // 例：'你的自訂token'；若 Edge Function 沒開驗證就留空字串或刪掉

    /* === 解析學號（優先沿用網址 ?stu；否則反查 books.student_id -> students.student_code） === */
  const A_URL  = 'https://wfhwhvodgikpducrhgda.supabase.co';
  const A_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmaHdodm9kZ2lrcGR1Y3JoZ2RhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgwMTAwNjEsImV4cCI6MjA2MzU4NjA2MX0.P6P-x4SxjiR4VdWH6VFgY_ktgMac_OzuI4Bl7HWskz8';
  let AClient = null;

  function getStuFromUrl(){
    const u = new URL(location.href);
    const code = (u.searchParams.get('stu') || '').trim();
    return code || null;
  }

  async function resolveStuCodeForBack(){
    // 1) 先沿用網址上的 ?stu
    const fromUrl = getStuFromUrl();
    if (fromUrl) return fromUrl;

    // 2) 反查本書 student_id -> 學號
    try{
      const r1 = await SB.from('books').select('student_id').eq('id', BOOK_ID).single();
      const sid = r1?.data?.student_id || null;
      if (!sid) return null;

      if (!AClient) AClient = window.supabase.createClient(A_URL, A_ANON, { auth:{ persistSession:false } });
      const r2 = await AClient.from('students').select('student_code').eq('student_id', sid).maybeSingle();
      const code = r2?.data?.student_code || null;
      return (code && String(code).trim()) || null;
    }catch(e){
      console.warn('[resolveStuCodeForBack] fallback failed:', e);
      return null;
    }
  }


  /* === 新增：成功儲存後要送的通知 === */
  async function notifyDiscordAfterSave() {
    const studentName = localStorage.getItem('player_username') || '未命名學生';
    const title = (window.ACTIVE_BOOK?.title || '未命名書籍').trim();
    const bookUrl = `https://shierusha.github.io/library/story/book?book=${encodeURIComponent(title)}`;

    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), 7000);
    try {
      const res = await fetch(NOTIFY_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({
          student_name: studentName,
          title,
          book_url: bookUrl,
          ...(SHARED_TOKEN ? { token: SHARED_TOKEN } : {})
        }),
        signal: ctrl.signal
      });
      if (!res.ok) {
        const msg = (res.headers.get('content-type')||'').includes('application/json')
          ? JSON.stringify(await res.json())
          : await res.text();
        console.warn('notify-discord failed:', res.status, msg);
      }
    } catch (e) {
      console.warn('notify-discord error:', e?.message || e);
    } finally {
      clearTimeout(timer);
    }
  }

  const normType = (t)=>{
    const x = String(t||'').trim().toLowerCase().replace(/-/g,'_');
    if (x==='divider_black') return 'divider_dark';
    if (x==='divider_white') return 'divider_light';
    if (x==='image')         return 'illustration';
    return (['novel','divider_light','divider_dark','illustration'].includes(x) ? x : 'novel');
  };
  const stripId = (obj)=>{ const { id, ...rest } = obj || {}; return rest; }; // 插入時移除 id

  // 內部 → DB ENUM（優先用 app.js 的 TypeMap；否則用後備轉換）
  const toDbTypeForPages = (t)=>{
    if (window.TypeMap?.toDbType) return window.TypeMap.toDbType(t);
    const x = String(t||'').trim().toLowerCase().replace(/-/g,'_');
    if (x==='divider_light' || x==='divider_white') return 'divider_white';
    if (x==='divider_dark'  || x==='divider_black') return 'divider_black';
    if (x==='illustration'  || x==='image')         return 'image';
    return 'novel';
  };

  async function saveAll({ navigateAfter = false } = {}) {
    if (!window.SB)      { alert('尚未登入或 SB 未建立'); return false; }
    if (!window.BOOK_ID) { alert('缺少 bookid');          return false; }
    const SB = window.SB;
    const bookId = window.BOOK_ID;

    const btnSave = document.getElementById('btnSave');
    const btnBack = document.getElementById('btnBack');
    [btnSave, btnBack].forEach(b => b && (b.disabled = true));

    const die = (tag, e) => {
      console.error(`[saveAll/${tag}]`, e);
      alert(`儲存失敗（${tag}）：` + (e?.hint || e?.details || e?.message || e));
      return false;
    };

    try {
      // 0) 畫面 → PAGES_DB
      try { window.syncAllStoriesToDB && window.syncAllStoriesToDB(); } catch(_) {}

      // 1) 更新 books
      const bookPatch = {
        title: (window.ACTIVE_BOOK?.title || '未命名書籍').trim(),
        direction: window.state?.direction || 'ltr',
        binding: window.state?.bind || 'short',
        cover_image: (window.ACTIVE_BOOK?.cover_image || '').trim() || null,
        page_count: Array.isArray(window.PAGES_DB) ? window.PAGES_DB.length : 0
      };
      {
        const r = await SB.from('books').update(bookPatch).eq('id', bookId).select('id').single();
        if (r.error) return die('update-books', r.error);
      }

      // 2) 讀 DB 現況
      const [dbPagesRes, dbChRes] = await Promise.all([
        SB.from('pages').select('id,page_index').eq('book_id', bookId).order('page_index', { ascending: true }),
        SB.from('chapters').select('id,page_id,title,pages!inner(id,page_index)').eq('book_id', bookId)
      ]);
      if (dbPagesRes.error) return die('select-pages', dbPagesRes.error);
      if (dbChRes.error)    return die('select-chapters', dbChRes.error);

      const dbPages = dbPagesRes.data || [];
      const dbPagesById = new Map(dbPages.map(r => [r.id, r]));
      const dbChapters = (dbChRes.data || []).map(r => ({ id:r.id, page_id:r.page_id, title:r.title, page_index:r.pages?.page_index||1 }));

      // 3) 新狀態（畫面上的頁）
      const desiredPages = (window.PAGES_DB || []).map((p, i) => ({
        id: p.id || null,
        book_id: window.BOOK_ID,
        page_index: i + 1,
        type: toDbTypeForPages(p.type),
        image_url: p.image_url || null,
        content_json: p.content_json
          ? p.content_json
          : { text_plain:'', text_html:'' } // 保底，避免 null 撞 schema
      }));

      const toUpdate = [];
      const toInsertRaw = [];
      const toDeleteIds = [];
      const desiredOldIds = new Set();

      desiredPages.forEach(dp => {
        if (dp.id) {
          const old = dbPagesById.get(dp.id);
          if (!old) {
            toInsertRaw.push(stripId(dp)); // 本地有 id 但 DB 找不到 → 視為新頁（插入時移除 id）
          } else {
            desiredOldIds.add(dp.id);
            if ((old.page_index|0) === (dp.page_index|0)) {
              toUpdate.push(dp); // 索引不變 → 直接 upsert
            } else {
              toInsertRaw.push(stripId(dp)); // 換位 → 新列（不帶 id）
              toDeleteIds.push(old.id);      // 稍後刪舊列
            }
          }
        } else {
          toInsertRaw.push(stripId(dp));     // 全新 → 插入（不帶 id）
        }
      });

      // DB 既有但不在 desired 的舊頁 → 刪
      dbPages.forEach(r => { if (!desiredOldIds.has(r.id)) toDeleteIds.push(r.id); });

      // 4) 更新索引不變的頁
      if (toUpdate.length) {
        const r = await SB.from('pages').upsert(toUpdate, { onConflict: 'id' }).select('id');
        if (r.error) return die('upsert-pages(stable)', r.error);
      }

      // ===== 關鍵調整：先刪後插，清出 (book_id, page_index) 唯一鍵空間 =====

      // 5) 章節：先刪掉指向「待刪舊頁」的章節（避免外鍵擋住下一步刪頁）
      const existingByPid = new Map(dbChapters.map(c => [c.page_id, c]));
      const toDeleteChIds = [];
      toDeleteIds.forEach(pid => { const ch = existingByPid.get(pid); if (ch) toDeleteChIds.push(ch.id); });
      if (toDeleteChIds.length) {
        const r = await SB.from('chapters').delete().in('id', toDeleteChIds);
        if (r.error) return die('delete-chapters(for-old-pages)', r.error);
      }

      // 6) 刪掉舊頁（釋放唯一索引）
      if (toDeleteIds.length) {
        const r = await SB.from('pages').delete().in('id', toDeleteIds);
        if (r.error) return die('delete-pages', r.error);
      }

      // 7) 再插入新頁（絕不含 id 欄位，交給 DB 產生）
      let inserted = [];
      if (toInsertRaw.length) {
        const r = await SB.from('pages').insert(toInsertRaw).select('id,page_index');
        if (r.error) return die('insert-pages', r.error);
        inserted = r.data || [];
        // 把新 id 寫回本地（之後章節要用）
        inserted.forEach(row => {
          const p = window.PAGES_DB[row.page_index - 1];
          if (p) p.id = row.id;
        });
      }

      // 8) 重建 page_index → page_id 對應
      const pageIndexToId = new Map();
      desiredPages.forEach(p => { if (p.id) pageIndexToId.set(p.page_index, p.id); });
      inserted.forEach(row => { pageIndexToId.set(row.page_index, row.id); });
      if (pageIndexToId.size !== desiredPages.length) {
        const r = await SB.from('pages').select('id,page_index').eq('book_id', window.BOOK_ID);
        if (!r.error) (r.data||[]).forEach(x => pageIndexToId.set(x.page_index, x.id));
      }

      // 9) 章節 upsert（以 page_id 為準）
      const wantList = (window.CHAPTERS_DB || [])
        .filter(ch => ch && ch.title && ch.page_index >= 1)
        .map(ch => {
          const pid = pageIndexToId.get(ch.page_index) || null;
          return pid ? { page_id: pid, title: String(ch.title).trim(), book_id: window.BOOK_ID } : null;
        })
        .filter(Boolean);

      const wantByPid = new Map(wantList.map(c => [c.page_id, c]));
      const chToInsert = [];
      const chToUpdate = [];

      wantByPid.forEach((w, pid) => {
        const ex = existingByPid.get(pid);
        if (!ex) chToInsert.push({ book_id: window.BOOK_ID, page_id: pid, title: w.title });
        else if ((ex.title || '') !== w.title) chToUpdate.push({ id: ex.id, title: w.title });
      });

      if (chToInsert.length) {
        const r = await SB.from('chapters').insert(chToInsert).select('id');
        if (r.error) return die('insert-chapters', r.error);
      }
      if (chToUpdate.length) {
        const r = await SB.from('chapters').upsert(chToUpdate, { onConflict: 'id' }).select('id');
        if (r.error) return die('upsert-chapters', r.error);
      }

      // 10) 成功後回抓一次 → 覆寫 LOCAL
      const [freshBook, freshPages, freshChJoin] = await Promise.all([
        SB.from('books')
          .select('id,title,cover_image,cover_color,binding,direction,page_count')
          .eq('id', window.BOOK_ID).single(),
        SB.from('pages')
          .select('id,page_index,type,image_url,content_json')
          .eq('book_id', window.BOOK_ID)
          .order('page_index', { ascending: true }),
        SB.from('chapters')
          .select('title,page_id,created_at,pages!inner(id,page_index)')
          .eq('book_id', window.BOOK_ID)
          .order('created_at', { ascending: true })
      ]);
      if (freshBook.error) return die('refresh-book', freshBook.error);
      if (freshPages.error) return die('refresh-pages', freshPages.error);
      if (freshChJoin.error) return die('refresh-chapters', freshChJoin.error);

      const chapters = (freshChJoin.data || [])
        .map(r => ({ title:r.title, page_index:r.pages?.page_index || 1 }))
        .sort((a,b)=> a.page_index - b.page_index);

      window.ACTIVE_BOOK = freshBook.data;
      window.PAGES_DB = (freshPages.data || []).map(p => ({
        ...p,
        type: (window.TypeMap?.fromDbType ? window.TypeMap.fromDbType(p.type) : normType(p.type))
      }));
      window.CHAPTERS_DB = chapters;
      try { window.persistDraft && window.persistDraft(); } catch(_) {}

      // 重繪（停留原本焦點頁）
      try {
        const focus = (window.EditorCore?.getFocusedDbIndex?.() || 1);
        window.rebuildTo && window.rebuildTo(focus);
      } catch(_) {}

      if (navigateAfter) location.href = BACK_URL;
      return true;

    } catch (e) {
      return die('unknown', e);
    } finally {
      const btnSave = document.getElementById('btnSave');
      const btnBack = document.getElementById('btnBack');
      [btnSave, btnBack].forEach(b => b && (b.disabled = false));
    }
  }

  // 綁定按鈕
  document.getElementById('btnSave')?.addEventListener('click', ()=> {
    saveAll({ navigateAfter: false });
  });

  document.getElementById('btnBack')?.addEventListener('click', async ()=> {
    const btnBack = document.getElementById('btnBack');
    if (btnBack) btnBack.disabled = true;
    const ok = await saveAll({ navigateAfter: false });
   if (ok) {
    await notifyDiscordAfterSave();
    const stu = await resolveStuCodeForBack(); // ← 新增
    const target = BACK_URL + (stu ? `?stu=${encodeURIComponent(stu)}` : ''); // ← 新增
    location.href = target; // ← 修改：帶著 ?stu 回去
  } else if (btnBack) {
    btnBack.disabled = false;
  }
  });
})();
</script>



<!-- A 站連動登出（玩家中心登出時，這頁自動跳回玩家中心） -->
<script src="https://shierusha.github.io/library/assets/js/logout.js"></script>




</body>
</html>
