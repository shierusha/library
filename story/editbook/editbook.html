<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>謝爾夏｜電子書編輯器</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- 字體 -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&family=Noto+Sans+TC:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
/* ========== Reset / Base ========== */
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:#e6ebff;
  font-family:'Noto Sans TC',system-ui,-apple-system,Segoe UI,sans-serif;
  background:#000 url('https://shierusha.github.io/school-battle/teachers/img/8.webp') center top / cover no-repeat fixed;
}
/* 隱藏滾動條但保留滾動 */
html, body { overflow-y: auto; }
body { -ms-overflow-style: none; scrollbar-width: none; }
body::-webkit-scrollbar { width:0; height:0; }

/* ========== App Bar ========== */
.appbar {
    position: fixed;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    background: rgba(15, 27, 51, .85);
    border-bottom: 1px solid #223057;
    height: 30px; 
    width: 100vw;
}
.brand{display:flex;gap:.6rem;align-items:center;font-weight:700}
#bookTitle{outline:none}
#bookTitle[contenteditable="true"]{border-bottom:1px dashed #8aa1ff}
.tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

/* ========== 舞台區 ========== */
.stage{
  position: absolute;
  left: 50%;
  top: 60px;
  transform: translateX(-50%);
  width: 90%;
  height: 100vh;
}
.scaler{ position:relative; width:100%; }

/* ========== 按鈕（保留你的） ========== */
.btn{ background:#16244a; border:1px solid #3a4a78; color:#fff; padding:2px 10px; border-radius:10px; cursor:pointer }
.btn.primary{ background:#6f82ff; border-color:#6f82ff }
.btn.danger{ background:#2a0f18; border-color:#6b1b2e; color:#ffb3c2 }
.btn.ghost{border-color:#ffffff33 }
.side{ position:fixed;  display:flex; gap:8px; z-index:90 }
.side.left{     left: 10px;   top: 33px; }
.side.right{ right:10px; top: 33px; }
.dock{ position:fixed; left:0; right:0; bottom:1%; display:flex; gap:10px; justify-content:center; z-index:90 }

/* ========== 文字方向（外觀） ========== */
.mode-ltr .page{ writing-mode: horizontal-tb; }
.mode-rtl .page{ writing-mode: vertical-rl;  letter-spacing: 0.1em; }
.mode-ltr .single-page{ writing-mode: horizontal-tb; }
.mode-rtl .single-page{ writing-mode: vertical-rl; letter-spacing: 0.1em; }

/* ===== BookFlip 必要 CSS（請勿移除） ===== */
.book, .book * { user-select:none; -webkit-user-select:none; }
.book { position:absolute; top:0; color:black; }
.paper {
  width:100%; height:100%;
  position:absolute; top:0; left:0;
  transform-style:preserve-3d;
  background:#FFF;
  border: 1px solid #555;
}
.page {
  width:100%; height:100%;
  position:absolute; top:0; left:0;
  display:flex;
  backface-visibility:hidden; -webkit-backface-visibility:hidden;
  padding: calc(20px * var(--scale, 1));
}
.back { transform: rotateY(180deg); }
.paper.dir-ltr { transform-origin: left center; }
.paper.dir-rtl { transform-origin: right center; }

.single-stage { width:100%; height:100%; position:relative; overflow:hidden; }
.single-page  { width:100%; height:100%; position:absolute; top:0; left:0; display:flex; will-change:transform; background:#FFF; padding: calc(20px * var(--scale, 1)); }

/* 字級比例（方案2） */
.book-scope { font-size: calc(16px * var(--scale, 1)); }

/* ========== 章節角標＋頁碼 ========== */
.page-meta { position: absolute; pointer-events: none;     font-size: .7em;    opacity: .7;}
.meta-chapter { max-width: 45%; }

.meta-tl { top: 5px;  left: 6px; }
.meta-tr { top: 5px;  right: 3px; }
.meta-bl { bottom: 5px; left: 6px; }
.meta-br { bottom: 5px; right: 6px; }

/* ========== 四種頁型（底線版） ========== */
.page.page--divider_light,
.single-page.page--divider_light,
.page.page--divider_dark,
.single-page.page--divider_dark {
  display:flex; align-items:center; justify-content:center; text-align:center;
}
/* 不顯示角標 */
.page--divider_light .page-meta,
.page--divider_dark  .page-meta,
.page--illustration  .page-meta { display:none !important; }
/* 配色 */
.page.page--divider_light, .single-page.page--divider_light { background:#fff; color:#000; }
.page.page--divider_dark,  .single-page.page--divider_dark  { background:#555; color:#fff; }
/* 圖片滿版 */
.page.page--illustration, .single-page.page--illustration {
  background-size: cover; background-position: center; background-repeat: no-repeat; padding:0 !important;
}

/* ========== TOC Modal（自適應高度） ========== */
.modal-overlay { position: fixed; inset: 0; z-index: 2000; display: none; align-items: center; justify-content: center; animation: modal-fadein-bg 0.25s; background: rgba(0,0,0,0.45); }
.modal-overlay.show { display: flex; }
@keyframes modal-fadein-bg { from { background: rgba(0,0,0,0);} to { background: rgba(0,0,0,0.45);} }
.modal-content { background: rgb(13 27 77 / 82%); border-radius: 18px; border: 2px solid #1eb5e5; box-shadow: 0 0 16px 2px #62f1fe88, 0 8px 32px #1eb5e5aa; width: 500px; max-width: 93vw; height: auto; max-height: 80vh; display: flex; flex-direction: column; overflow: hidden; animation: modal-pop 0.32s cubic-bezier(.42,1.4,.51,1.01); }
@keyframes modal-pop { from { opacity: 0; transform: scale(0.92);} to { opacity: 1; transform: scale(1);} }
.modal-header { background: none; padding: 15px 20px 0px 24px; color: #fff; font-size: 1.5em; font-weight: bold; letter-spacing: 1px; text-shadow: 0 1px 4px #000a; }
.modal-header::after { content: ""; display: block; height: 5px; width: 70%; margin: 0.5rem 0 0 0; border-radius: 2px; background: linear-gradient(to right, #53e2ff99 65%, #53e2ff00 100%); pointer-events: none; }
.modal-body { color: #fff; padding: 12px 24px 16px 24px; font-size: 1.05em; line-height: 1.55; text-shadow: 0 1px 4px #0008; overflow-y: auto; word-break: break-word; white-space: normal; max-height: 64vh; scrollbar-width: none; -ms-overflow-style: none; }
.modal-body::-webkit-scrollbar { display: none; }
.toc-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 6px 0; border-bottom: 1px dashed #53e2ff33; cursor: pointer; }
.toc-row:hover { background: #0d1b4d66; }
.toc-row .toc-title { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.toc-row .toc-page  { opacity: .9; }

/* 讓頁碼永遠水平書寫（單頁/雙頁都適用） */
.page .meta-page,
.single-page .meta-page {
  writing-mode: horizontal-tb !important;
  text-orientation: mixed !important; /* 確保數字不是直立顯示 */
  letter-spacing: 0 !important;       /* 避免繼承垂直模式的字距 */
  text-combine-upright: none !important;
}

/* 650px 以下換版型 */
@media (max-width: 650px) {
.stage{height: 85vh;}
#bookTitle {    width: 10em;}
.appbar {    height: 65px;}
.tools {    gap: 1px;    flex-direction: column-reverse;}
.stage {  top: 85px;  width: 80%;}
.side.right {bottom: 65px;        left: 50%;        transform: translateX(-50%);        right: 0px;        top: auto;        justify-content: center;        width: 100%;}
.side.left {    top: 65px;}}


    /* 編輯時不要出現巨大黑框/外框 */
.story { outline: none !important; }
.story:focus { outline: none !important; box-shadow: none !important; border: none !important; }
/* 也一併避免點擊高亮 */
.story { -webkit-tap-highlight-color: transparent; }
/* 你本來就有 overflow:hidden；再保險一下不顯示滾動條 */
.story::-webkit-scrollbar { width: 0; height: 0; }


  </style>
</head>

<body class="mode-ltr">
  <!-- 上方導覽 -->
  <div class="appbar">
    <div class="brand">書名:<span id="bookTitle" contenteditable="true">未命名書籍</span></div>
    <div class="tools">
      <div>
        <span>頁面數：</span><b id="lblCount">0</b>
        <span style="width:5px"></span>
      </div>
      <div>
        <button class="btn primary" id="btnSave">儲存</button>
        <button class="btn" id="btnBack">回書單</button>
      </div>
    </div>
  </div>

  <!-- 左側工具列（TOC 不再隱藏） -->
  <div class="side left">
    <button class="btn ghost" id="btnTOC">目錄</button>
    <button class="btn ghost" id="btnFontUp">A+</button>
    <button class="btn ghost" id="btnFontDown">A-</button>
    <button class="btn ghost" id="btnBold"><b>B</b></button>
    <button class="btn ghost" id="btnItalic"><i>I</i></button>
    <button class="btn ghost" id="btnUnderline"><u>U</u></button>
  </div>

  <!-- 右側工具列 -->
  <div class="side right">
   <button class="btn ghost" id="btnToggleDir" style="display: none;">文字方向</button>
    <button class="btn ghost" id="btnToggleBind" style="display: none;">長/短邊</button>
    <button class="btn ghost" id="btnToggleView">單/雙頁</button>
  </div>

  <!-- 中央舞台 -->
  <div class="stage">
    <div class="scaler" id="scaler">
      <div class="book" id="bookCanvas">
        <!-- ✅ 封面保留（插件不覆蓋） -->
        <div class="paper">
          <div class="page front">首頁</div>
          <div class="page back"></div>
        </div>
        <!-- 正文由 JS 追加 -->
      </div>
    </div>
  </div>

  <!-- 下方 Dock（不隱藏） -->
<div class="dock" style="bottom:34px;">

    <button class="btn ghost" id="btnStageMinus"> - </button>
    <button class="btn ghost" id="btnleft">&lt;</button>
    <button class="btn" id="btnInsertChapter">插入/修改章節</button>
    <button class="btn" id="btnInsertPage" >新增紙</button>
    <button class="btn danger" id="btnDeleteBlank">刪除白紙</button>
    <button class="btn ghost" id="btnright">&gt;</button>
    <button class="btn ghost" id="btnStagePlus"> + </button>
  </div>
  <div class="dock">
    <button class="btn" data-style="novel">一般文本</button>
    <button class="btn" data-style="divider-light">白置中</button>
    <button class="btn" data-style="divider-dark">黑置中</button>
    <button class="btn" data-style="illustration">圖片頁</button>
  </div>

  <!-- TOC Modal -->
  <div id="tocModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="tocTitle">
      <div class="modal-header" id="tocTitle">目錄</div>
      <div class="modal-body" id="tocBody"></div>
    </div>
  </div>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
 <script>
/* Editor 啟動參數（用書櫃交換的長簽） */
(function () {
  const SUPABASE_URL = "https://ogzpfrkwnqqaitytncla.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9nenBmcmt3bnFxYWl0eXRuY2xhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxODQzNzEsImV4cCI6MjA3MDc2MDM3MX0.Ls83xOXcKIW7FUcavr8_sOs37I18VGFWYNW3sNFRS24";

  const url = new URL(location.href);
  const bookId = url.searchParams.get('bookid') || '';
  if (!bookId) alert('缺少 ?bookid= 參數');
  window.BOOK_ID = bookId;

  // 從書櫃頁存的長簽（和你書櫃一致）
  const token = localStorage.getItem('xer_b_jwt') || '';

  window.SB = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
    global: { headers: token ? { Authorization: `Bearer ${token}` } : {} }
  });
})();
</script>


  <!-- 外掛-->
  <script src="book-flip.js"></script>
  <!-- 應用層-->
<script src="app.js"></script>
<script src="editor-core.js"></script>
<script src="sheet-ops.js"></script>
<script src="paste-flow.js"></script>
<script src="text-controls.js"></script>
<!-- 放在你的 <script src="text-controls.js"></script> 後面即可 -->
<script>
/* chapters.js — 插入/編輯章節（LOCAL）
 * - 依目前頁（EditorCore.getFocusedDbIndex）新增/編輯/移除章節
 * - 寫回 CHAPTERS_DB + persistDraft() + 角標重繪
 */
(function () {
  if (!window.EditorCore) return;

  const btn = document.getElementById('btnInsertChapter');
  if (!btn) return;

  function upsertChapterAt(dbIndex, title) {
    if (!Array.isArray(window.CHAPTERS_DB)) window.CHAPTERS_DB = [];

    const t = (title || '').trim();
    const i = CHAPTERS_DB.findIndex(ch => (ch.page_index|0) === (dbIndex|0));

    if (t === '') {
      // 空值 → 移除該頁章節
      if (i >= 0) CHAPTERS_DB.splice(i, 1);
    } else {
      if (i >= 0) {
        CHAPTERS_DB[i].title = t;
      } else {
        CHAPTERS_DB.push({ title: t, page_index: dbIndex|0 });
      }
    }

    CHAPTERS_DB.sort((a, b) => (a.page_index|0) - (b.page_index|0));

    try { window.persistDraft && window.persistDraft(); } catch(_) {}

    // 角標/頁碼立即更新（章節角標靠它）
    try { window.renderMetaForAllPages && renderMetaForAllPages(); } catch(_) {}
  }

  function onClickInsertChapter() {
    // 取得目前頁；封面（dbIndex=0）就視為第 1 頁
    let dbIndex = window.EditorCore.getFocusedDbIndex() || 1;
    if (dbIndex <= 0) dbIndex = 1;

    // 帶入原標題（若該頁已是章節）
    const existing = (window.CHAPTERS_DB || []).find(ch => (ch.page_index|0) === (dbIndex|0));
    const defaultTitle = existing ? existing.title : '';

    const title = prompt('請輸入章節名稱（留空=不設定/刪除）：', defaultTitle);
    if (title === null) return; // 取消不動作

    upsertChapterAt(dbIndex, title);
  }

  btn.addEventListener('click', onClickInsertChapter);

  // 導出（給其他模組需要時呼叫）
  window.Chapters = { upsertChapterAt };
})();
</script>

<script src="page-style.js"></script>
<script>
/* －／＋ 調整 .stage 寬度，每次 5%，不做任何持久化 */
(function () {
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
  }

  onReady(function () {
    const stageEl = document.querySelector('.stage');
    const minus   = document.getElementById('btnStageMinus');
    const plus    = document.getElementById('btnStagePlus');
    if (!stageEl || !minus || !plus) return;

    const STEP = 5, MIN = 20, MAX = 140;
    const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));

    // 初始：若沒設定 inline，預設 90%
    let pct = (function () {
      const m = /(\d+(?:\.\d+)?)%/.exec(stageEl.style.width || '');
      return m ? +m[1] : 90;
    })();

    function reflow(){
      if (typeof window.applyLayout === 'function') window.applyLayout();
      if (typeof window.afterLayoutRedraw === 'function') window.afterLayoutRedraw();
      if (typeof window.applyLayout !== 'function' && typeof window.afterLayoutRedraw !== 'function') {
        window.dispatchEvent(new Event('resize'));
      }
    }
    function apply(){
      pct = clamp(Math.round(pct), MIN, MAX);
      stageEl.style.width = pct + '%';
      reflow();
    }
    function dec(){ pct -= STEP; apply(); }
    function inc(){ pct += STEP; apply(); }

    minus.addEventListener('click', dec);
    plus .addEventListener('click', inc);

    // 依目前值先套一次（不影響原本 90% 外觀）
    apply();
  });
})();
</script>
  <script>
/* ===== 差異化儲存到資料庫（upsert + 精準刪除）===== */
(function(){
  const BACK_URL = 'https://shierusha.github.io/library/story/book-chest';

  const normType = (t)=>{
    const x = String(t||'').trim().toLowerCase().replace(/-/g,'_');
    if (x==='divider_black') return 'divider_dark';
    if (x==='divider_white') return 'divider_light';
    if (x==='image')         return 'illustration';
    return (['novel','divider_light','divider_dark','illustration'].includes(x) ? x : 'novel');
  };

  async function saveAll({ navigateAfter = false } = {}) {
    if (!window.SB)      { alert('尚未登入或 SB 未建立'); return false; }
    if (!window.BOOK_ID) { alert('缺少 bookid');          return false; }

    const SB     = window.SB;
    const bookId = window.BOOK_ID;
    const btnSave = document.getElementById('btnSave');
    const btnBack = document.getElementById('btnBack');
    [btnSave, btnBack].forEach(b => b && (b.disabled = true));

    try {
      // 0) 先把畫面 → PAGES_DB
      try { window.syncAllStoriesToDB && window.syncAllStoriesToDB(); } catch(_) {}

      // 1) 更新 books 基本欄位
      const bookPatch = {
        title: (window.ACTIVE_BOOK?.title || '未命名書籍').trim(),
        direction: window.state?.direction || 'ltr',
        binding: window.state?.bind || 'short',
        cover_image: (window.ACTIVE_BOOK?.cover_image || '').trim() || null,
        page_count: Array.isArray(window.PAGES_DB) ? window.PAGES_DB.length : 0
      };
      const upBook = await SB.from('books').update(bookPatch).eq('id', bookId).select('id').single();
      if (upBook.error) throw upBook.error;

      // 2) 讀取資料庫目前 pages 與 chapters（做 diff）
      const [dbPagesRes, dbChRes] = await Promise.all([
        SB.from('pages').select('id,page_index').eq('book_id', bookId).order('page_index', { ascending: true }),
        SB.from('chapters').select('id,page_id,title,pages!inner(id,page_index)').eq('book_id', bookId)
      ]);
      if (dbPagesRes.error) throw dbPagesRes.error;
      if (dbChRes.error) throw dbChRes.error;

      const dbPages = dbPagesRes.data || [];
      const dbPageIdSet = new Set(dbPages.map(r=>r.id));
      const dbChapters = (dbChRes.data || []).map(r => ({ id:r.id, page_id:r.page_id, title:r.title, page_index:r.pages?.page_index||1 }));

      // 3) 準備 PAGES 的 diff
      const desiredPages = (window.PAGES_DB || []).map((p, i) => ({
        id: p.id || null,
        book_id: bookId,
        page_index: i + 1,
        type: normType(p.type),
        image_url: p.image_url || null,
        content_json: p.content_json ? p.content_json : { text_plain:'', text_html:'' }
      }));

      const toInsert = desiredPages.filter(p => !p.id);
      const toUpdate = desiredPages.filter(p => p.id && dbPageIdSet.has(p.id));
      const desiredIdSet = new Set(desiredPages.filter(p=>p.id).map(p=>p.id));
      const toDeleteIds = dbPages.filter(r => !desiredIdSet.has(r.id)).map(r => r.id);

      // 4) 先 upsert 更新既有頁（onConflict=id）
      if (toUpdate.length){
        const upP = await SB.from('pages').upsert(toUpdate, { onConflict: 'id' }).select('id');
        if (upP.error) throw upP.error;
      }

      // 5) 插入新頁，取回新 id
      let insertedPages = [];
      if (toInsert.length){
        const insP = await SB.from('pages').insert(toInsert).select('id,page_index');
        if (insP.error) throw insP.error;
        insertedPages = insP.data || [];
        // 把新 id 補回 PAGES_DB，避免後續再存時沒 id
        insertedPages.forEach(row=>{
          const dp = window.PAGES_DB[row.page_index - 1];
          if (dp) dp.id = row.id;
        });
      }

      // 6) 刪除被移除的頁
      if (toDeleteIds.length){
        const delP = await SB.from('pages').delete().in('id', toDeleteIds);
        if (delP.error) throw delP.error;
      }

      // 建立 page_index → page_id 映射（含新插入的）
      const pageIndexToId = new Map();
      // 既有（更新後依舊有效）
      desiredPages.forEach(p=>{
        if (p.id) pageIndexToId.set(p.page_index, p.id);
      });
      // 新增
      insertedPages.forEach(r=>{
        pageIndexToId.set(r.page_index, r.id);
      });

      // 7) Chapters 差異化處理（以 page_id 為準，一頁一章節）
      const existingByPid = new Map(dbChapters.map(c => [c.page_id, c]));
      const wantList = (window.CHAPTERS_DB || [])
        .filter(ch => ch && ch.title && ch.page_index >= 1)
        .map(ch => {
          const pid = pageIndexToId.get(ch.page_index) || null;
          return pid ? { page_id: pid, title: String(ch.title).trim() } : null;
        })
        .filter(Boolean);

      const wantByPid = new Map(wantList.map(c => [c.page_id, c]));
      const chToInsert = [];
      const chToUpdate = [];
      const chToDeleteIds = [];

      // 要插／改
      wantByPid.forEach((want, pid) => {
        const ex = existingByPid.get(pid);
        if (!ex) chToInsert.push({ book_id: bookId, page_id: pid, title: want.title });
        else if ((ex.title || '') !== want.title) chToUpdate.push({ id: ex.id, title: want.title });
      });

      // 要刪
      existingByPid.forEach((ex, pid) => {
        if (!wantByPid.has(pid)) chToDeleteIds.push(ex.id);
      });

      if (chToInsert.length){
        const insC = await SB.from('chapters').insert(chToInsert).select('id');
        if (insC.error) throw insC.error;
      }
      if (chToUpdate.length){
        // PostgREST 沒有 bulk patch by id；改 upsert onConflict=id
        const upC = await SB.from('chapters').upsert(chToUpdate, { onConflict:'id' }).select('id');
        if (upC.error) throw upC.error;
      }
      if (chToDeleteIds.length){
        const delC = await SB.from('chapters').delete().in('id', chToDeleteIds);
        if (delC.error) throw delC.error;
      }

      // 8) 成功後回抓一次 → 覆寫 LOCAL
      const [freshBook, freshPages, freshChJoin] = await Promise.all([
        SB.from('books')
          .select('id,title,cover_image,cover_color,binding,direction,page_count')
          .eq('id', bookId).single(),
        SB.from('pages')
          .select('id,page_index,type,image_url,content_json')
          .eq('book_id', bookId)
          .order('page_index', { ascending: true }),
        SB.from('chapters')
          .select('title,page_id,created_at,pages!inner(id,page_index)')
          .eq('book_id', bookId)
          .order('created_at', { ascending: true })
      ]);
      if (freshBook.error) throw freshBook.error;
      if (freshPages.error) throw freshPages.error;
      if (freshChJoin.error) throw freshChJoin.error;

      const chapters = (freshChJoin.data || [])
        .map(r => ({ title:r.title, page_index:r.pages?.page_index || 1 }))
        .sort((a,b)=> a.page_index - b.page_index);

      window.ACTIVE_BOOK = freshBook.data;
      window.PAGES_DB    = freshPages.data || [];
      window.CHAPTERS_DB = chapters;
      try { window.persistDraft && window.persistDraft(); } catch(_) {}

      // 畫面也輕量重繪一次（可保留）
      try {
        const focus = (window.EditorCore?.getFocusedDbIndex?.() || 1);
        window.rebuildTo && window.rebuildTo(focus);
      } catch(_) {}

      if (navigateAfter) location.href = BACK_URL;
      return true;

    } catch (e) {
      console.error('[saveAll] failed:', e);
      alert('儲存失敗：' + (e?.message || e));
      return false;
    } finally {
      [btnSave, btnBack].forEach(b => b && (b.disabled = false));
    }
  }

  // 綁定兩顆按鈕：儲存、不跳；返回＝先存成功才跳
  document.getElementById('btnSave')?.addEventListener('click', ()=> {
    saveAll({ navigateAfter: false });
  });
  document.getElementById('btnBack')?.addEventListener('click', async ()=> {
    const ok = await saveAll({ navigateAfter: false });
    if (ok) location.href = BACK_URL;
  });
})();
</script>



</body>
</html>
